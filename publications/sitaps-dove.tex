\documentclass{article}
\usepackage{listings}
\usepackage{syntax}

\begin{document}
\title{Dove and Ivory: Verifying One DSL with Another}
\author{Tom Hawkins, Howard Reubenstein, Greg Eakman, BAE Systems Inc.}
\date{\today}
\maketitle

\begin{abstract}
Dove (a \underline{D}SL \underline{O}perational \underline{V}erification \underline{E}nvironment)
is a language to capture verification conditions (VCs) for the 
Ivory DSL for verifying user and compiler generated assertions
and procedure contracts.  VCs from an Ivory program are
translated into Dove then into ACL2 for formal analysis.
Verified assertions and contracts are then optimized out of
the Ivory program for improved runtime performance.
This paper provides an overview of the Dove language,
the VC generation strategy, the translation from Ivory to Dove
and Dove to ACL2.  Verification results are highlighted
and future extensions discussed.
\end{abstract}

% http://www.cs.utexas.edu/users/moore/acl2/workshop-2015/index.html

\section{Problem Definition}

Developed under DARPA HACMS, Ivory is a DSL in Haskell for 
embedded programming.  Ivory is similar to C and provides
memory safety, enforced by its type system.
To capture design intent, Ivory has
assertions, assumptions, and procedure contracts.
In addition, the Ivory compiler generates
assertions to guard a program against a host of runtime violations including
floating point exceptions, numerical overflows, index casting, and unbounded loops.

Verification of these assertions are crucial for two reasons.  First and foremost,
assertions are still runtime checks, and failure of such are equivalent 
to uncaught exceptions (think Ariane 5).  This importance cannot
be underscored in HACMS, since an Ivory autopilot will be flying a real helicopter
with an onboard safety pilot.  Second, runtime checks have
runtime overhead: if these checks and their associated logic can be safely
removed, memory consumption and execution time are reduced; important 
for embedded systems, which often run under tight resource constrains.

To address both of these concerns and tackle the problem of Ivory program
verification, we created Dove (a \underline{D}SL \underline{O}perational \underline{V}erification \underline{E}nvironment)
as both a language and a verification environment.  Like Ivory,
Dove is a DSL embedded in Haskell.  The Dove library provides all the 
constructs for the language as well as the VC generator, the Dove optimizer,
and the interface to the backend prover, ACL2.

What follows is an overview of the Dove verification strategy,
an overview of the Dove language, a detailed look at the translation from
Ivory into Dove, and then how Dove is translated to ACL2.
We conclude with results (verification performance) of various tests,
provide a comparison between Dove and other similar systems,
and discuss possible future extensions
to the Dove language and verifier and using Dove to target other programming
languages and paradigms.

\subsection{Interprocedural Verification and Runtime Check Optimization with Dove}

In Dove, Ivory program verification is taken one procedure at a time.
Starting at a procedure's arguments, the Dove verifier traverses
the procedure's body generating VCs for assertions and post-conditions along the way.
To optimize-out proven checks, the verifier maintains a working copy of the procedure's AST.
When an assertion or post-condition check is verified, the runtime check is removed.
After verification, the modified AST is passed to a conventional optimizer and code generator.

During the traversal, the verifier accumulates a database of lemmas
to aid the verification of future checks in a procedure.
These include pre-conditions ({\tt requires}) on arguments
and any prior check performed on a given branch, regardless of whether the check was verified.
Checks that fail to prove remain in the generated code
as do procedure pre-conditions; the later to avoid potential issues with
recursive procedures.

To help scale to global program verification,
procedure calls are abstracted with the callee's procedure contracts.
Specifically, the callee's pre-conditions ({\tt requires}) are asserted
and the post-conditions ({\tt ensures}) are added to the lemma database.

\section{Dove Language Syntax}

Dove is a declarative language with out side effects.  A Dove
program only contains expressions, no statements.
Dove has three basic types: unit, booleans, and integers;
and provides literal expressions to introduce values
of these types:
\setlength{\grammarindent}{10em}
\begin{grammar}
  <expr> ::= `()' | <boolean-literal> | <integer-literal>

  <boolean-literal> ::= true | false
\end{grammar}

Variables can be introduced into scope either by a non-recursive \texttt{let}
binding or by the universal quantifier:

\begin{grammar}
  <expr> ::= let <variable> = <expr> in <expr>
    \alt forall <variable> in <expr>
\end{grammar}

Of course, variables themselves are expressions:

\begin{grammar}
  <expr> ::= <variable>
\end{grammar}

To build up larger data structures, Dove has two composite types: arrays and records.
Arrays can be constructed from a list of expressions, arrays can be appended
together, arrays can be indexed (i.e. array projection), and arrays can be 
updated given an index, a value, and a base array:

\begin{grammar}
  <expr> ::= `[' <expr> \{ , <expr> \} `]'
    \alt <expr> ++ <expr>
    \alt <expr> `[' <expr> `]'
    \alt `(' update <expr> <expr> <expr> `)'
\end{grammar}

Likewise, records can be contructed from a list of name-value pairs,
records can be indexed given a record and a field name, and two
records can be overlayed, one over the other, the first overwriting
any fields that are common in the second:

\begin{grammar}
  <expr> ::= `\{' <field-name> = <expr> \{ , <field-name> = <expr> \} `\}'
    \alt <expr> . <field-name>
    \alt `(' overlay <expr> <expr> `)'
\end{grammar}

Also, Dove has a conditional expression and a handful of unary and binary operators:

\begin{grammar}
  <expr> ::= if <expr> then <expr> else <expr>
    \alt `(' <unary-operator> <expr> `)'
    \alt `(' <binary-operator> <expr> <expr> `)'

  <unary-operator> ::= not
    \alt isUnit
    \alt isBool
    \alt isInt
    \alt isArray
    \alt isRecord
    \alt arrayLength
    \alt intNegate 
    \alt intAbs

  <binary-operators> ::= and
    \alt or
    \alt implies
    \alt eq
    \alt lt
    \alt gt
    \alt +
    \alt -
    \alt *
    \alt mod
\end{grammar}

\section{Translating Ivory to Dove VCs}

Before we give a detailed account of the translation process, it helps to see an 
example of how a small Ivory procedure is translated into the various VCs in Dove.

TODO: Ivory to Dove example with factorial, or similar.


\section{Underlying Verification Infrastructure}

The verification and optimization traversal
of an Ivory procedure happens in a StateT monad called \texttt{IVO}
(for \underline{I}vory \underline{V}erification and \underline{O}ptimization).
Not only does this monad translate Ivory into Dove, it also performs the Dove to ACL2
translation and makes calls to ACL2 to verify the VCs as they are generated.
The state maintained by \texttt{IVO} holds
counters for Dove variable generation\footnote{For improved legibility of the generted VCs,
dove generates distinct variable names
for VCs, assumed conditions, branch conditions, free variables,
environments, and stacks.},
the Dove representation of the Ivory procedure thus far,
the currrent branch,
a list of accumulated lemmas,
the current environment and stack, and an accumlation
of encountered return points.
The \texttt{IVO} monad allows us to write
succint transformers (Ivory to Ivory) and translators (Ivory to Dove),
including:

\begin{lstlisting}
  -- Rewrite Ivory statement blocks.
  block :: I.Block -> IVO I.Block
  
  -- Rewrite Ivory statements.
  stmt :: I.Stmt -> IVO I.Stmt
  
  -- Convert an Ivory expression to a Dove expression.
  expr :: I.Expr -> IVO Expr
  
  -- Convert Ivory operators to Dove expressions.
  intrinsic :: I.ExpOp -> [Expr] -> IVO Expr
\end{lstlisting}

Another benefit of this monadic approach is that it
eases the construction of a set of reusable verification combinators,
such as for variable name generation and inserting code annotations, 
some of which are shown below:

\begin{lstlisting}
  -- Define a new branching condition (BC).
  newBC :: I.Expr -> IVO Expr
  
  -- Create a new free variable.
  newFree :: IVO Expr
  
  -- Add new procedure body logic.
  addBody :: (Expr -> Expr) -> IVO ()
  
  -- Insert a comment.
  comment :: String -> IVO ()
  
  -- Insert a nested comment.
  comment' :: String -> IVO a -> IVO a
  
  -- Add a return expression.
  addReturn :: Expr -> IVO ()
  
  -- Get all the return expressions in the procedure.
  getReturns :: IVO [Expr]
\end{lstlisting}

Since environments and stacks play an important role
in capturing the semantics of Ivory programs, 
a subset of these combinators is dedicated their
management:

\begin{lstlisting}
  -- Given a record expression representing an environment, create
  -- a new environment variable and set it as the current environment.
  newEnv :: Expr -> IVO ()
  
  -- Get the current environment.
  getEnv :: IVO Expr
  
  -- Set the current environment.
  setEnv :: Expr -> IVO ()
  
  -- With the current environment, do something in IVO then restore
  -- the environment on the return.
  withEnv :: IVO a -> IVO a
  
  -- Extend the current environment with a name and a value.
  extendEnv :: String -> Expr -> IVO ()
  
  -- Lookup a name in the current environment.
  lookupEnv :: String -> IVO Expr

  -- Given a stack expression, create a new stack variable
  -- and set it as the current stack.
  newStack :: Expr -> IVO ()
  
  -- Get the current stack.
  getStack :: IVO Expr
  
  -- Extends the stack with a value and returns the
  -- pointer (index) to the stack location.
  extendStack :: Expr -> IVO Expr
  
  -- Update the current stack given an index and value.
  updateStack :: Expr -> Expr -> IVO ()
  
  -- Given an index, dereference the assocated value on the stack.
  lookupStack :: Expr -> IVO Expr
  
  -- Create a new stack of free variables, but keeps
  -- the stack size the same.
  freeStack :: IVO ()
\end{lstlisting}

With these basic combinators in place, translating many Ivory
constructs is just a matter of composing these combinators.
For example, an Ivory dereference (\texttt{I.Deref t v r})
has a type (\texttt{t}), the variable introduced that
will hold the dereferenced value (\texttt{v}), and
the reference expression (\texttt{r}).  The translation
process entails these steps:

\begin{enumerate}
  \item Translate the reference expression into Dove.
  \item Use the reference to lookup the value on the stack.
  \item Extend the current environment by binding the referenced
        stack value to the variable \texttt{v}.
\end{enumerate}

With our verification combinators in \texttt{IVO}, these
three steps are a one-liner Haskell:

\begin{lstlisting}
    I.Deref _ v r -> expr r >>= lookupStack >>= extendEnv (var v)
\end{lstlisting}

Likewise, Ivory's stack allocation statement (\texttt{I.allocRef t r v})
is translated by:

\begin{enumerate}
  \item Lookup the variable \texttt{v} in the current environment.
  \item Extend the stack with the value of the variable \texttt{v}.
  \item Extend the environment with the variable \texttt{r} as the reference to the new stack allocation.
\end{enumerate}

Again, these operations are performed in a single line of Haskell:

\begin{lstlisting}
  I.AllocRef _ r v -> lookupEnv (var v) >>= extendStack >>= extendEnv (var r)
\end{lstlisting}


%TODO
%\begin{itemize}
%  \item Both Ivory and Dove are DSLs embedded in Haskell.  Makes for a clean AST to AST translation.
%  \item Describe verifier monad: captures lemma database, AST transformations.
%  \item Detail how Ivory AST elements are encoded into Dove.
%  \item Comments are good: Ivory AST elements are heavily commented and hierarchically group during translation.
%  \item Areas of Ivory language not supported or handled conservatively:
%  \begin{itemize}
%    \item Recursion: all procedure requires left in place.
%    \item Loops.
%    \item Floating point: all FP operations are taken a free variables.
%    \item Stack is not maintained across procedure calls.
%  \end{itemize}
%\end{itemize}

\section{Translating Dove to ACL2}
TODO
\begin{itemize}
  \item Dove optimization.
  \item Mention ACL2 DSL.
  \item ACL2 translation.  Discuss handling of global storage and stack.
\end{itemize}

\section{Practical Verification}
TODO
\begin{itemize}
  \item An attempt to make these tools user friendly to designers/verification engineers.
  \item Controlled verbosity.  Output progress, failures, VC, optimized VC, ACL2, ACL2 result.
\end{itemize}

\section{Results}
TODO
\begin{itemize}
  \item Results from testsuite.
  \item Results from Galois: quadcopter or Boeing littler bird?  Probably not likely.  Maybe can add/adapt ivory-model-checking examples.
\end{itemize}

\section{Survey of Similar Verification Systems}
TODO
(For conference paper the related work section will need to be 
pretty strong -- maybe we can get some additional eyes on this -- 
of course it may turn out that this work is too similar -- interesting
but still too similar -- to some already published approach)
\begin{itemize}
  \item Frama-C (Why3)
  \item Spark Ada
\end{itemize}

\section{Future Work}
TODO
\begin{itemize}
  \item Address limitations: no floating point, no stack across calls, no loops, bitwise operations.
  \item Incorporate other backends (SMT, WHY3).
  \item Target other languages: pointer operations (Cish); Breeze type, contract, and maybe IFC checking; HDLs.
  \begin{itemize}
    \item Pointer operation is C-like language.
    \item Breeze type checking, contract checking, and maybe IFC checking.
    \item Hardware description languages for FPGA design.
    \item Integrity verification in presents of bit corruption, e.g. formalizing fault simulation in PERFECT.
  \end{itemize}
\end{itemize}

\section{Conclusions}
We presented an overview of the Dove language and verification environment
and how it is applied to Ivory programs,
specifically the verification and optimization of runtime checks.

TODO
\begin{itemize}
  \item About 75\% success rate on testsuite.
  \item Fast execution.  Provide numbers.
  \item Primary limitations include loops, stack across calls, floating point.  Stack problems can be address with a better contract language.
\end{itemize}

\end{document}

